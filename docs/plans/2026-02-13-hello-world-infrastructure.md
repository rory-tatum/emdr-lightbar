# Hello World Infrastructure Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Set up the complete build pipeline — native C build, Unity tests, Emscripten WASM build, and GitHub Actions CI/CD deploying to GitHub Pages — proven with a hello world program.

**Architecture:** A `hello_message()` function in `src/main.c` returns a greeting string. `main()` prints it. Unity tests verify the function. Emscripten compiles it to WASM. A hand-written `web/index.html` loads the WASM module and displays stdout output. GitHub Actions runs tests, builds WASM, and deploys to Pages.

**Tech Stack:** C99, GNU Make, Unity test framework (git submodule), Emscripten (emcc), GitHub Actions, GitHub Pages

---

### Task 1: Create .gitignore

**Files:**
- Create: `.gitignore`

**Step 1: Write .gitignore**

```
# Build output
build/

# Emscripten WASM output (generated by make wasm)
web/main.js
web/main.wasm
```

**Step 2: Commit**

```bash
git add .gitignore
git commit -m "Add .gitignore for build and WASM output"
```

---

### Task 2: Add Unity test framework as git submodule

**Files:**
- Create: `lib/unity/` (submodule)

**Step 1: Add the submodule**

```bash
git submodule add https://github.com/ThrowTheSwitch/Unity.git lib/unity
```

**Step 2: Verify the submodule was added**

```bash
ls lib/unity/src/unity.h
```

Expected: file exists

**Step 3: Commit**

```bash
git add .gitmodules lib/unity
git commit -m "Add Unity test framework as git submodule"
```

---

### Task 3: Write the hello world source with testable function

**Files:**
- Create: `include/main.h`
- Create: `src/main.c`

**Step 1: Create the header**

`include/main.h`:
```c
#ifndef MAIN_H
#define MAIN_H

const char *hello_message(void);

#endif
```

**Step 2: Create the source**

`src/main.c`:
```c
#include <stdio.h>
#include "main.h"

const char *hello_message(void) {
    return "Hello, World!";
}

int main(void) {
    printf("%s\n", hello_message());
    return 0;
}
```

**Step 3: Commit**

```bash
git add include/main.h src/main.c
git commit -m "Add hello world source with testable hello_message function"
```

---

### Task 4: Write the Unity test

**Files:**
- Create: `test/test_main.c`

**Step 1: Write the failing test**

`test/test_main.c`:
```c
#include "unity.h"
#include "main.h"
#include <string.h>

void setUp(void) {}
void tearDown(void) {}

void test_hello_message_returns_greeting(void) {
    TEST_ASSERT_EQUAL_STRING("Hello, World!", hello_message());
}

int main(void) {
    UNITY_BEGIN();
    RUN_TEST(test_hello_message_returns_greeting);
    return UNITY_END();
}
```

**Step 2: Commit**

```bash
git add test/test_main.c
git commit -m "Add Unity test for hello_message"
```

---

### Task 5: Create the Makefile

**Files:**
- Create: `Makefile`

**Step 1: Write the Makefile**

```makefile
CC = gcc
CFLAGS = -std=c99 -Wall -Wextra -Iinclude
EMCC = emcc

UNITY_SRC = lib/unity/src/unity.c
UNITY_INC = -Ilib/unity/src

SRC = src/main.c
TEST_SRC = test/test_main.c

.PHONY: native test wasm clean

native: build/main
	@echo "Native build complete: build/main"

build/main: $(SRC) include/main.h | build
	$(CC) $(CFLAGS) -o $@ $(SRC)

build:
	mkdir -p build

test: build/test_main
	./build/test_main

build/test_main: $(TEST_SRC) $(SRC) include/main.h | build
	$(CC) $(CFLAGS) $(UNITY_INC) -DUNITY_INCLUDE_DOUBLE -o $@ \
		$(TEST_SRC) src/main.c $(UNITY_SRC) \
		-Dmain=__original_main

wasm: web/main.js
	@echo "WASM build complete: web/main.js web/main.wasm"

web/main.js: $(SRC) include/main.h
	$(EMCC) $(CFLAGS) -o $@ $(SRC)

clean:
	rm -rf build/
	rm -f web/main.js web/main.wasm
```

Note on `build/test_main`: We use `-Dmain=__original_main` to rename the `main` in `src/main.c` so it doesn't conflict with the test runner's `main`. The test links against `src/main.c` directly to access `hello_message()`.

**Step 2: Verify native build works**

```bash
make native
./build/main
```

Expected output: `Hello, World!`

**Step 3: Verify tests pass**

```bash
make test
```

Expected: Unity output showing 1 test, 0 failures

**Step 4: Commit**

```bash
git add Makefile
git commit -m "Add Makefile with native, test, wasm, and clean targets"
```

---

### Task 6: Create the web page

**Files:**
- Create: `web/index.html`

**Step 1: Write the HTML shell**

`web/index.html`:
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EMDR Lightbar</title>
    <style>
        body {
            font-family: monospace;
            background: #1a1a2e;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
        }
        h1 { color: #0ff; }
        #output {
            background: #16213e;
            padding: 1em 2em;
            border-radius: 8px;
            border: 1px solid #0f3460;
            margin-top: 1em;
            white-space: pre;
        }
    </style>
</head>
<body>
    <h1>EMDR Lightbar</h1>
    <div id="output">Loading WASM...</div>
    <script>
        var Module = {
            print: function(text) {
                document.getElementById('output').textContent = text;
            },
            printErr: function(text) {
                console.error(text);
            }
        };
    </script>
    <script src="main.js"></script>
</body>
</html>
```

**Step 2: Verify WASM build works (requires Emscripten installed locally)**

```bash
make wasm
```

If Emscripten is not installed locally, this is fine — CI will handle it. The important thing is the HTML file is correct.

**Step 3: Commit**

```bash
git add web/index.html
git commit -m "Add web page shell for Emscripten WASM output"
```

---

### Task 7: Create the GitHub Actions workflow

**Files:**
- Create: `.github/workflows/ci.yml`

**Step 1: Write the workflow**

`.github/workflows/ci.yml`:
```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Build and run tests
        run: make test

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup Emscripten
        uses: mymindstorm/setup-emsdk@v14

      - name: Build WASM
        run: make wasm

      - name: Setup Pages
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        uses: actions/configure-pages@v5

      - name: Upload Pages artifact
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        uses: actions/upload-pages-artifact@v3
        with:
          path: web/

      - name: Deploy to GitHub Pages
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        id: deployment
        uses: actions/deploy-pages@v4
```

**Step 2: Commit**

```bash
git add .github/workflows/ci.yml
git commit -m "Add GitHub Actions workflow for test, WASM build, and Pages deploy"
```

---

### Task 8: Create CLAUDE.md

**Files:**
- Create: `CLAUDE.md`

**Step 1: Write CLAUDE.md**

```markdown
# EMDR Lightbar

Oscillating LED strip controller for EMDR therapy with web-based visualization.

## Architecture

- **Core logic** (`src/`, `include/`) — Platform-agnostic C99. Pure functions
  implementing oscillation state. No I/O or hardware dependencies.
- **Web visualization** (`web/`) — Core logic compiled to WASM via Emscripten.
  HTML page renders LED state. Deployed to GitHub Pages.
- **MCU driver** (future) — Thin wrapper calling core logic to drive LED strip
  on Arduino Uno.

## Build Commands

- `make native` — compile to native binary in `build/`
- `make test` — compile and run Unity tests
- `make wasm` — compile to WASM via Emscripten into `web/`
- `make clean` — remove all build artifacts

## Project Structure

- `src/` — C source files (core logic)
- `include/` — C headers
- `test/` — Unity test files (`test_*.c`)
- `web/` — HTML page + generated WASM (`.js`/`.wasm` are gitignored)
- `lib/unity/` — Unity test framework (git submodule)
- `build/` — Native build output (gitignored)

## Conventions

- C99 standard, `-Wall -Wextra`
- No platform-specific code in `src/` — keep core logic portable
- Every function in core logic must have a Unity test
- Tests go in `test/test_<module>.c`
- Frequent, small commits

## CI/CD

GitHub Actions (`.github/workflows/ci.yml`):
1. Runs `make test` on every push and PR
2. Builds WASM via Emscripten
3. Deploys `web/` to GitHub Pages on pushes to `main`

## Dependencies

- GCC (native build)
- Emscripten (WASM build — installed automatically in CI)
- Unity test framework (vendored as git submodule in `lib/unity/`)
```

**Step 2: Commit**

```bash
git add CLAUDE.md
git commit -m "Add CLAUDE.md with project conventions and build instructions"
```

---

### Task 9: Push and verify CI

**Step 1: Push to origin**

```bash
git push origin main
```

**Step 2: Check that the Actions workflow starts**

```bash
gh run list --limit 1
```

Expected: a workflow run in progress or completed

**Step 3: Once CI passes, verify GitHub Pages deployment**

The site should be live at `https://rory-tatum.github.io/emdr-lightbar/` showing "Hello, World!" from the WASM module.

Note: GitHub Pages may need to be enabled in repo settings (Source: GitHub Actions) if not already configured. Check with:
```bash
gh api repos/rory-tatum/emdr-lightbar/pages 2>/dev/null || echo "Pages not yet configured"
```

If not configured:
```bash
gh api repos/rory-tatum/emdr-lightbar/pages -X POST -f build_type=workflow
```
